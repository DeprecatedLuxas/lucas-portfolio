import process from "node:process";
import { mkdir, rm, writeFile } from "node:fs/promises";
import { spawn } from "node:child_process";
import { graphql } from "@octokit/graphql";
import { remark } from "remark";
import remarkComment from "remark-comment";
import { $fetch } from "ofetch";
import { visit } from "unist-util-visit";
import type { ProjectRCResponse } from "@luxass/projectrc";
import { type Language, type Repository, type User, gql } from "github-schema";

function isExternalLink(url: string) {
  // there is probably a better way to do this
  return url.startsWith("http");
}

function rewrite(options: { repoUrl: string }) {
  // @ts-expect-error - hmmm what types should i use?
  return function transformer(tree) {
    visit(tree, "link", (node) => {
      if (!node?.url) {
        throw new Error("No URL found");
      }
      if (isExternalLink(node.url)) {
        return;
      }
      const newUrl = new URL(node.url, `${options.repoUrl}/blob/main/`);
      node.url = newUrl.toString();
    });
  };
}

const BANNER
  = "// THIS FILE IS AUTOGENERATED BY ./scripts/update-site.ts. DO NOT EDIT THIS FILE DIRECTLY.";

type Project = Pick<
  Repository,
  "name" | "nameWithOwner" | "description" | "pushedAt" | "url"
> & {
  $projectrc?: ProjectRCResponse["$projectrc"]
  $values?: ProjectRCResponse["projects"][number]
  language?: Pick<Language, "name" | "color">
  defaultBranch?: string
  isContributor: boolean

};

const REPOS_TO_INCLUDE: string[] = [];
const REPOS_TO_IGNORE: string[] = [".github"];

const PROFILE_QUERY = gql`
  #graphql
  query getProfile {
    viewer {
      repositories(
        first: 100
        isFork: false
        privacy: PUBLIC
        orderBy: { field: STARGAZERS, direction: DESC }
      ) {
        totalCount
        nodes {
          name
          isFork
          isPrivate
          nameWithOwner
          description
          pushedAt
          url
          defaultBranchRef {
            name
          }
          languages(first: 1, orderBy: { field: SIZE, direction: DESC }) {
            nodes {
              name
              color
            }
          }
          object(expression: "HEAD:.github") {
            ... on Tree {
              entries {
                name
                type
                path
              }
            }
          }
        }
        pageInfo {
          endCursor
          hasNextPage
        }
      }
      contributions: repositoriesContributedTo(
        privacy: PUBLIC
        first: 100
        contributionTypes: [
          COMMIT
          ISSUE
          PULL_REQUEST
          REPOSITORY
          PULL_REQUEST_REVIEW
        ]
      ) {
        nodes {
          nameWithOwner
        }
      }
    }
  }
`;

async function run() {
  if (!process.env.GITHUB_TOKEN) {
    throw new Error("No GITHUB_TOKEN found");
  }

  const { viewer } = await graphql<{
    viewer: Omit<User, "repositoriesContributedTo"> & {
      contributions: User["repositoriesContributedTo"]
    }
  }>(PROFILE_QUERY, {
    headers: {
      "Authorization": `bearer ${process.env.GITHUB_TOKEN}`,
      "Content-Type": "application/json",
    },
  });

  if (!viewer) {
    throw new Error("No profile found");
  }

  try {
    await $fetch("https://projectrc.luxass.dev/ping", {
      responseType: "text",
    });
  } catch (err) {
    console.error(err);
    throw new Error("Failed to ping projectrc.luxass.dev");
  }

  await rm("./src/content/projects", {
    force: true,
    recursive: true,
  });
  await mkdir("./src/content/projects");

  if (!viewer.repositories.nodes?.length) {
    throw new Error("No repositories found");
  }

  const projects: Project[] = [];

  const repositories = viewer.repositories.nodes.filter(
    (repo): repo is NonNullable<Repository> => {
      return (
        !!repo
        && !repo.isFork
        && !repo.isPrivate
        && !REPOS_TO_IGNORE.includes(repo.nameWithOwner)
        && !REPOS_TO_IGNORE.includes(repo.nameWithOwner.split("/")[1])
      );
    },
  );

  for (const repository of repositories) {
    console.log(`Fetching .projectrc for ${repository.nameWithOwner}`);
    const projectRCResponse = await $fetch<ProjectRCResponse>(
      `https://projectrc.luxass.dev/api/projectrc/${repository.nameWithOwner}`,
      {
        ignoreResponseError: true,
      },
    );

    const projectRC
      = typeof projectRCResponse === "object" ? projectRCResponse : undefined;

    let language = {
      name: "Unknown",
      color: "#333",
    };

    // check if user is a contributor
    const isContributor
      = viewer.contributions.nodes?.some(
        (contribution) =>
          contribution?.nameWithOwner === repository.nameWithOwner,
      ) ?? false;

    if (repository.languages?.nodes?.length && repository.languages.nodes[0]) {
      language = {
        name: repository.languages.nodes[0].name,
        color: repository.languages.nodes[0].color || "#333",
      };
    }
    if (!projectRC) {
      if (!REPOS_TO_INCLUDE.includes(repository.nameWithOwner)) {
        continue;
      }

      projects.push({
        name: repository.name,
        nameWithOwner: repository.nameWithOwner,
        description: repository.description,
        pushedAt: repository.pushedAt,
        url: repository.url,
        defaultBranch: repository.defaultBranchRef?.name || undefined,
        isContributor,
        language,
      });
      continue;
    }

    for (const project of projectRC.projects) {
      if (project.readme) {
        const fileName = project.name.replace(/^\./, "").replace(/\./g, "-");

        const file = await remark()
          .use(remarkComment)
          .use(rewrite, {
            repoUrl: repository.url,
          })
          .process(project.readme.content || "No README was found.");
        const frontmatter = `---
                    handle: ${project.name}
                    name: ${project.name}
                    owner: ${repository.nameWithOwner.split("/")[0]}
                    description: ${repository.description}
                    githubUrl: ${repository.url}${project.npm ? `\nnpm: ${project.npm}` : ""
          }
                    ---`
          .split("\n")
          .map((line) => line.trim())
          .join("\n");

        await writeFile(
          `./src/content/projects/${fileName}.mdx`,
          `${frontmatter}\n\n${file.toString()}`,
        );
      }

      projects.push({
        name: project.name,
        nameWithOwner: repository.nameWithOwner,
        description: project.description || repository.description,
        pushedAt: repository.pushedAt,
        url: repository.url,
        defaultBranch: repository.defaultBranchRef?.name || undefined,
        isContributor,
        language,
        $projectrc: projectRC.$projectrc,
        $values: project,
      });
    }
  }

  const types = "export type Project = typeof projects[number];";

  const code = `${BANNER} \n\n${types} \n\nexport const projects = ${JSON.stringify(
    projects.filter(Boolean),
    null,
    2,
  )}; \n`;

  await writeFile("./src/data/projects.ts", code);

  // format projects.ts with eslint
  spawn("npx", ["eslint", "--fix", "./src/data/projects.ts"]);
}

run().catch((err) => {
  console.error(err);
  process.exit(1);
});
