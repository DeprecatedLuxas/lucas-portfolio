#!/usr/bin/env bun

import process from "node:process";
import { graphql } from "@octokit/graphql";
import z from "zod";

const BANNER
  = "// THIS FILE IS AUTOGENERATED BY ./scripts/update-site.ts. DO NOT EDIT THIS FILE DIRECTLY.";

interface Profile {
  user: User
}

interface User {
  repositories: Repositories
}

interface Repositories {
  totalCount: number
  nodes: RepositoryNode[]
  pageInfo: PageInfo
}

interface LanguageNode {
  name: string
  color: string
}

interface ObjectEntry {
  name: string
  type: "blob" | "tree"
  path: string
}

interface RepositoryNode {
  nameWithOwner: string
  description: string
  pushedAt: string
  url: string
  defaultBranchRef: {
    name: string
  }
  isPrivate: boolean
  isFork: boolean
  languages: {
    nodes: LanguageNode[]
  }
  object: {
    entries: ObjectEntry[]
  }
}

interface PageInfo {
  endCursor: string
  hasNextPage: boolean
}

interface ProjectRC {
  readme: boolean
  npm: boolean
  ignore: boolean
}

function gql(raw: TemplateStringsArray, ...keys: string[]): string {
  return keys.length === 0 ? raw[0]! : String.raw({ raw }, ...keys);
}

const PROJECTRC_SCHEMA = z.object({
  readme: z.boolean().optional().default(false),
  npm: z.boolean().optional().default(false),
  ignore: z.boolean().optional().default(false),
});

const REPOS_TO_IGNORE: string[] = [];

const REPOS_TO_INCLUDE: string[] = ["SchemaStore/schemastore"];

const PROFILE_NAME = process.env.PROFILE_NAME ?? "luxass";

const PROFILE_QUERY = gql`#graphql
  query getProfile($name: String!) {
    user(login: $name) {
      repositories(
        first: 100
        isFork: false
        privacy: PUBLIC
        orderBy: { field: STARGAZERS, direction: DESC }
      ) {
        totalCount
        nodes {
          isFork
          isPrivate
          nameWithOwner
          description
          pushedAt
          url
          defaultBranchRef {
            name
          }
          languages(first: 1, orderBy: { field: SIZE, direction: DESC }) {
            nodes {
              name
              color
            }
          }
          object(expression: "HEAD:.github") {
            ... on Tree {
              entries {
                name
                type
                path
              }
            }
          }
        }
        pageInfo {
          endCursor
          hasNextPage
        }
      }
    }
  }
`;

const REPOSITORY_QUERY = gql`#graphql
  query getRepository($owner: String!, $name: String!) {
    repository(owner: $owner, name: $name) {
      isFork
      isPrivate
      nameWithOwner
      description
      pushedAt
      url
      defaultBranchRef {
        name
      }
      languages(first: 1, orderBy: { field: SIZE, direction: DESC }) {
        nodes {
          name
          color
        }
      }
      object(expression: "HEAD:.github") {
        ... on Tree {
          entries {
            name
            type
            path
          }
        }
      }
    }
  }
`;

async function run() {
  if (!process.env.GITHUB_TOKEN) {
    throw new Error("No GITHUB_TOKEN found");
  }

  const { user } = await graphql<Profile>(PROFILE_QUERY, {
    name: PROFILE_NAME,
    headers: {
      "Authorization": `bearer ${process.env.GITHUB_TOKEN}`,
      "Content-Type": "application/json",
    },
  });

  if (!user) {
    throw new Error("No profile found");
  }

  const extraRepos = await Promise.all(
    REPOS_TO_INCLUDE.map(async (repo) => {
      let nameWithOwner = repo;
      if (!repo.includes("/")) {
        nameWithOwner = `${PROFILE_NAME}/${repo}`;
      }
      const { repository } = await graphql<{
        repository: RepositoryNode
      }>(REPOSITORY_QUERY, {
        owner: nameWithOwner.split("/")[0],
        name: nameWithOwner.split("/")[1],
        headers: {
          "Authorization": `bearer ${process.env.GITHUB_TOKEN}`,
          "Content-Type": "application/json",
        },
      });

      if (!repository) {
        throw new Error(`No repository found for ${nameWithOwner}`);
      }

      return repository;
    }),
  );

  const repoPromises = user.repositories.nodes
    .concat(extraRepos)
    .filter(
      (repo) =>
        !REPOS_TO_IGNORE.includes(repo.nameWithOwner)
        && !repo.isFork
        && !repo.isPrivate,
    )
    .map(async (repo) => {
      const projectrc = repo.object?.entries?.find(
        (entry) =>
          entry.name === ".projectrc" || entry.name === ".projectrc.json",
      );
      if (!projectrc) {
        return {
          ...repo,
          projectrc: undefined,
        };
      }

      const defaultBranch = repo.defaultBranchRef.name;
      console.log(
        `Fetching .projectrc for ${repo.nameWithOwner} from ${projectrc.path} on url ${repo.url}/blob/${defaultBranch}/${projectrc.path}?raw=true`,
      );

      const projectrcContent = await fetch(
        `${repo.url}/blob/${defaultBranch}/${projectrc.path}?raw=true`,
      ).then((res) => res.text());

      const parseResult = PROJECTRC_SCHEMA.safeParse(
        JSON.parse(projectrcContent),
      );

      if (!parseResult.success) {
        throw new Error(`Failed to parse .projectrc for ${repo.nameWithOwner}`);
      }

      const projectrcParsed = parseResult.data;

      return {
        ...repo,
        projectrc: projectrcParsed,
      };
    });

  const repos: (RepositoryNode & {
    projectrc?: ProjectRC
  })[] = await Promise.all(repoPromises);

  const types = "export type Project = typeof projects[number];";

  const projects = repos.filter(Boolean);

  const code = `${BANNER}\n\n${types}\n\nexport const projects = ${JSON.stringify(projects, null, 2)};\n`;

  await Bun.write("./src/data/projects.ts", code);
}

run().catch((err) => {
  console.error(err);
  process.exit(1);
});
