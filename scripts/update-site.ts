import process from "node:process";
import { mkdir, rm, writeFile } from "node:fs/promises";
import { spawn } from "node:child_process";
import {
  Buffer,
} from "node:buffer";
import { graphql } from "@octokit/graphql";
import { remark } from "remark";
import remarkComment from "remark-comment";
import {
  $fetch,
} from "ofetch";

import {
  visit,
} from "unist-util-visit";

interface ProjectRCResponse {
  raw: ProjectRC
  readme?: string
  npm?: string
}

function isExternalLink(url: string) {
  // there is probably a better way to do this
  return url.startsWith("http");
}

function rewrite(options: { repoUrl: string }) {
  console.log("OPTIONS", options);

  return function transformer(tree, file) {
    visit(tree, "link", (node) => {
      if (!node?.url) {
        throw new Error("No URL found");
      }
      if (isExternalLink(node.url)) {
        return;
      }
      const newUrl = new URL(node.url, `${options.repoUrl}/blob/main/`);
      node.url = newUrl.toString();
    });
  };
}

interface ProjectRC {
  readme?: boolean | string
  npm?: boolean | string
  ignore?: boolean
}
const BANNER
  = "// THIS FILE IS AUTOGENERATED BY ./scripts/update-site.ts. DO NOT EDIT THIS FILE DIRECTLY.";

interface Profile {
  viewer: Viewer
}

interface Viewer {
  repositories: Repositories
  contributions: {
    nodes: {
      nameWithOwner: string
    }[]
  }
}

interface Repositories {
  totalCount: number
  nodes: RepositoryNode[]
  pageInfo: PageInfo
}

interface LanguageNode {
  name: string
  color: string
}

interface ObjectEntry {
  name: string
  type: "blob" | "tree"
  path: string
}

interface RepositoryNode {
  name: string
  nameWithOwner: string
  description: string
  pushedAt: string
  url: string
  defaultBranchRef: {
    name: string
  }
  isPrivate: boolean
  isFork: boolean
  languages: {
    nodes: LanguageNode[]
  }
  object: {
    entries: ObjectEntry[]
  } | null
}

type Project = Pick<
  RepositoryNode,
  "name" | "nameWithOwner" | "description" | "pushedAt" | "url"
> & {
  projectrc?: ProjectRCResponse
  language?: LanguageNode
  defaultBranch?: string
  isContributor: boolean
};

interface PageInfo {
  endCursor: string
  hasNextPage: boolean
}

function gql(raw: TemplateStringsArray, ...keys: string[]): string {
  return keys.length === 0 ? raw[0]! : String.raw({ raw }, ...keys);
}

const REPOS_TO_IGNORE: string[] = [".github"];

const REPOS_TO_INCLUDE: string[] = ["SchemaStore/schemastore"];

const PROFILE_NAME = process.env.PROFILE_NAME ?? "luxass";

const PROFILE_QUERY = gql`
  #graphql
  query getProfile {
    viewer {
      repositories(
        first: 100
        isFork: false
        privacy: PUBLIC
        orderBy: { field: STARGAZERS, direction: DESC }
      ) {
        totalCount
        nodes {
          name
          isFork
          isPrivate
          nameWithOwner
          description
          pushedAt
          url
          defaultBranchRef {
            name
          }
          languages(first: 1, orderBy: { field: SIZE, direction: DESC }) {
            nodes {
              name
              color
            }
          }
          object(expression: "HEAD:.github") {
            ... on Tree {
              entries {
                name
                type
                path
              }
            }
          }
        }
        pageInfo {
          endCursor
          hasNextPage
        }
      }
      contributions: repositoriesContributedTo(privacy:PUBLIC, first:100, contributionTypes:[COMMIT, ISSUE, PULL_REQUEST, REPOSITORY,PULL_REQUEST_REVIEW]) {
        nodes {
          nameWithOwner
        }
      }
    }
  }
`;

const REPOSITORY_QUERY = gql`
  #graphql
  query getRepository($owner: String!, $name: String!) {
    repository(owner: $owner, name: $name) {
      name
      isFork
      isPrivate
      nameWithOwner
      description
      pushedAt
      url
      defaultBranchRef {
        name
      }
      languages(first: 1, orderBy: { field: SIZE, direction: DESC }) {
        nodes {
          name
          color
        }
      }
      object(expression: "HEAD:.github") {
        ... on Tree {
          entries {
            name
            type
            path
          }
        }
      }
    }
  }
`;

async function run() {
  if (!process.env.GITHUB_TOKEN) {
    throw new Error("No GITHUB_TOKEN found");
  }

  const { viewer } = await graphql<Profile>(PROFILE_QUERY, {
    headers: {
      "Authorization": `bearer ${process.env.GITHUB_TOKEN}`,
      "Content-Type": "application/json",
    },
  });

  if (!viewer) {
    throw new Error("No profile found");
  }

  const extraRepos = await Promise.all(
    REPOS_TO_INCLUDE.map(async (repo) => {
      let nameWithOwner = repo;
      if (!repo.includes("/")) {
        nameWithOwner = `${PROFILE_NAME}/${repo}`;
      }
      const { repository } = await graphql<{
        repository: RepositoryNode
      }>(REPOSITORY_QUERY, {
        owner: nameWithOwner.split("/")[0],
        name: nameWithOwner.split("/")[1],
        headers: {
          "Authorization": `bearer ${process.env.GITHUB_TOKEN}`,
          "Content-Type": "application/json",
        },
      });

      if (!repository) {
        throw new Error(`No repository found for ${nameWithOwner}`);
      }

      return repository;
    }),
  );

  await rm("./src/content/projects", {
    force: true,
    recursive: true,
  });
  await mkdir("./src/content/projects");

  const projectPromises: Promise<Project | undefined>[] = viewer.repositories.nodes
    .concat(extraRepos)
    .filter(
      (repo) =>
        !REPOS_TO_IGNORE.includes(repo.nameWithOwner)
        && !REPOS_TO_IGNORE.includes(repo.nameWithOwner.split("/")[1])
        && !repo.isFork
        && !repo.isPrivate,
    )
    .map(async (repo) => {
      const projectRCResponse = await $fetch<ProjectRCResponse>(`https://projectrc.luxass.dev/api/projectrc/${repo.nameWithOwner}`, {
        ignoreResponseError: true,
      });

      const projectrc = typeof projectRCResponse === "object" ? projectRCResponse : undefined;

      let language = {
        name: "Unknown",
        color: "#333",
      };

      const isContributor = viewer.contributions.nodes.some(
        (contribution) => contribution.nameWithOwner === repo.nameWithOwner,
      );

      if (repo.languages?.nodes?.length) {
        language = repo.languages.nodes[0];
      }

      const defaultBranch = repo.defaultBranchRef?.name || undefined;

      if (!projectrc) {
        if (!REPOS_TO_INCLUDE.includes(repo.nameWithOwner)) {
          return undefined;
        }

        return {
          name: repo.name,
          nameWithOwner: repo.nameWithOwner,
          description: repo.description,
          pushedAt: repo.pushedAt,
          url: repo.url,
          defaultBranch,
          projectrc: undefined,
          language,
          isContributor,
        };
      }

      if (projectrc.raw.readme) {
        const fileName = repo.name.replace(/^\./, "").replace(/\./g, "-");

        const { content, encoding } = await $fetch<{ content: string; encoding: string }>(projectrc.readme!, {
          ignoreResponseError: true,
        });

        if (encoding !== "base64") {
          console.error("Unknown encoding", encoding);
        }

        const readme = Buffer.from(content, "base64").toString("utf-8");

        const file = await remark().use(remarkComment).use(rewrite, {
          repoUrl: repo.url,
        }).process(readme || "No README was found.");
        const frontmatter = `---
            handle: ${repo.name}
            name: ${repo.name}
            owner: ${repo.nameWithOwner.split("/")[0]}
            description: ${repo.description}
            githubUrl: ${repo.url}
            ${(projectrc.raw.npm && projectrc.npm) ? `npm: ${projectrc.npm}` : ""}
            ---`.split("\n").map((line) => line.trim()).join("\n");

        await writeFile(`./src/content/projects/${fileName}.mdx`, `${frontmatter}\n\n${file.toString()}`);
      }

      return {
        name: repo.name,
        nameWithOwner: repo.nameWithOwner,
        description: repo.description,
        pushedAt: repo.pushedAt,
        url: repo.url,
        defaultBranch,
        projectrc,
        language,
        isContributor,
      };
    });

  const projects = await Promise.all(projectPromises);

  const types = "export type Project = typeof projects[number];";

  const code = `${BANNER} \n\n${types} \n\nexport const projects = ${JSON.stringify(
    projects.filter(Boolean),
    null,
    2,
  )
    }; \n`;

  await writeFile("./src/data/projects.ts", code);

  // format projects.ts with eslint
  spawn("npx", ["eslint", "--fix", "./src/data/projects.ts"]);
}

run().catch((err) => {
  console.error(err);
  process.exit(1);
});
